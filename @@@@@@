// ===== ADD SILENT REFRESH INTERCEPTOR =====
if (!axios.__SILENT_REFRESH__) {
  axios.__SILENT_REFRESH__ = true;

  axios.interceptors.response.use(
    response => response,
    async error => {
      const originalRequest = error.config;

      if (!error.response) {
        return Promise.reject(error);
      }

      const status = error.response.status;
      const errorCode = error.response.data?.error;

      // ðŸ”´ HARD FAIL â†’ concurrent login / session expired
      if (
        status === 401 &&
        (errorCode === "CONCURRENT_LOGIN" ||
         errorCode === "SESSION_EXPIRED")
      ) {
        navigate("/");
        return Promise.reject(error);
      }

      // ðŸŸ¢ TOKEN EXPIRED â†’ SILENT REFRESH
      if (
        status === 401 &&
        errorCode === "TOKEN_EXPIRED" &&
        !originalRequest._retry
      ) {
        originalRequest._retry = true;

        if (isRefreshing) {
          return new Promise((resolve, reject) => {
            failedQueue.push({ resolve, reject });
          }).then(token => {
            originalRequest.headers.Authorization = "Bearer " + token;
            return axios(originalRequest);
          });
        }

        isRefreshing = true;

        try {
          const refreshToken = localStorage.getItem("refreshToken");
          if (!refreshToken) throw new Error("No refresh token");

          const { data } = await axios.post(
            "/auth/refresh-token",
            { refreshToken }
          );

          localStorage.setItem("accessToken", data.accessToken);
          localStorage.setItem("refreshToken", data.refreshToken);

          axios.defaults.headers.common.Authorization =
            "Bearer " + data.accessToken;

          processQueue(null, data.accessToken);
          isRefreshing = false;

          originalRequest.headers.Authorization =
            "Bearer " + data.accessToken;

          return axios(originalRequest);

        } catch (refreshErr) {
          processQueue(refreshErr, null);
          isRefreshing = false;
          navigate("/");
          return Promise.reject(refreshErr);
        }
      }

      return Promise.reject(error);
    }
  );
}
