// LoginPort.test.jsx
import React from "react";
import { vi, describe, it, expect, beforeEach, afterEach } from "vitest";
import { render, screen, fireEvent, waitFor } from "@testing-library/react";
import axios from "axios";
import LoginPort from "./LoginPort"; // <-- जर फाईल वेगळ्या path मध्ये असेल तर इथे बदल कर

// ----------------- Mocks -----------------
vi.mock("axios");

// Mock child components used by LoginPort:
// adjust these paths if your imports in LoginPort.jsx use a different relative path.
vi.mock("./LoginWithPassword", () => {
  return {
    __esModule: true,
    default: ({ userId, openLoginErrorDialog, onBackToHome }) => (
      <div data-testid="mock-password">
        PasswordComponent for {userId}
        <button onClick={() => openLoginErrorDialog("errTitle", "errContent")}>openErr</button>
        <button onClick={onBackToHome}>back</button>
      </div>
    ),
  };
});

vi.mock("./UpdatePassword", () => {
  return {
    __esModule: true,
    default: ({ userId, onUpdateSuccess }) => (
      <div data-testid="mock-update">
        UpdateComponent for {userId}
        <button onClick={onUpdateSuccess}>success</button>
      </div>
    ),
  };
});

vi.mock("./LoginErrorDialog", () => {
  return {
    __esModule: true,
    default: ({ showErrorDialog, title, content, onDialogClose }) =>
      showErrorDialog ? (
        <div data-testid="mock-error-dialog">
          <div>{title}</div>
          <div>{content}</div>
          <button onClick={onDialogClose}>close</button>
        </div>
      ) : null,
  };
});

// ----------------- Helpers / lifecycle -----------------
beforeEach(() => {
  vi.clearAllMocks();
});
afterEach(() => {
  // cleanup is automatic by testing-library
});

// ----------------- Tests -----------------
describe("LoginPort component", () => {
  it("fetches content on mount (axios.get called) and renders basic text", async () => {
    axios.get.mockResolvedValueOnce({
      data: {
        brand: { title: "Test Brand" },
        hero: { welcomeTitle: "Welcome" },
        form: { signIn: "Sign in", userIdPlaceholder: "Enter id" },
      },
    });

    render(<LoginPort />);

    // wait for useEffect loadContent to call axios.get
    await waitFor(() => expect(axios.get).toHaveBeenCalledWith("/loginContent.json"));

    // sanity check: some expected text from content should be present
    expect(screen.queryByText(/Test Brand|Welcome|Sign in/i)).not.toBeNull();
  });

  it("valid user (ACTIVE + password active) -> shows LoginWithPassword (PASSWORD page)", async () => {
    axios.get.mockResolvedValueOnce({
      data: { form: { signIn: "Sign in", userIdPlaceholder: "Enter id" } },
    });

    axios.post.mockResolvedValueOnce({
      data: { userStatus: "ACTIVE", passwordLoginStatus: "ACTIVE", updatePassword: false },
    });

    render(<LoginPort />);

    await waitFor(() => expect(axios.get).toHaveBeenCalled());

    const userInput = screen.getByLabelText(/User ID/i);
    fireEvent.change(userInput, { target: { value: "t1234567" } });

    const submitButton = screen.getByRole("button", { name: /Sign in|sign in|submit/i });
    fireEvent.click(submitButton);

    await waitFor(() => expect(axios.post).toHaveBeenCalled());

    // mocked LoginWithPassword renders data-testid="mock-password"
    expect(screen.getByTestId("mock-password")).toBeInTheDocument();
    expect(screen.getByText(/PasswordComponent for/i)).toBeInTheDocument();
  });

  it("API returns updatePassword === true -> shows UpdatePassword (UPDATE page)", async () => {
    axios.get.mockResolvedValueOnce({
      data: { form: { signIn: "Sign in", userIdPlaceholder: "Enter id" } },
    });

    axios.post.mockResolvedValueOnce({
      data: { userStatus: "ACTIVE", passwordLoginStatus: "INACTIVE", updatePassword: true },
    });

    render(<LoginPort />);

    await waitFor(() => expect(axios.get).toHaveBeenCalled());

    const userInput = screen.getByLabelText(/User ID/i);
    fireEvent.change(userInput, { target: { value: "t1234567" } });

    const submitButton = screen.getByRole("button", { name: /Sign in|sign in|submit/i });
    fireEvent.click(submitButton);

    await waitFor(() => expect(axios.post).toHaveBeenCalled());

    expect(screen.getByTestId("mock-update")).toBeInTheDocument();
    expect(screen.getByText(/UpdateComponent for/i)).toBeInTheDocument();
  });

  it("invalid user -> opens LoginErrorDialog", async () => {
    axios.get.mockResolvedValueOnce({
      data: { form: { signIn: "Sign in", userIdPlaceholder: "Enter id" } },
    });

    axios.post.mockResolvedValueOnce({
      data: { userStatus: null, passwordLoginStatus: null, updatePassword: false, message: "User ID does not exist" },
    });

    render(<LoginPort />);
    await waitFor(() => expect(axios.get).toHaveBeenCalled());

    const userInput = screen.getByLabelText(/User ID/i);
    fireEvent.change(userInput, { target: { value: "unknown" } });

    const submitButton = screen.getByRole("button", { name: /Sign in|sign in|submit/i });
    fireEvent.click(submitButton);

    await waitFor(() => expect(axios.post).toHaveBeenCalled());

    expect(screen.getByTestId("mock-error-dialog")).toBeInTheDocument();
    expect(screen.getByText(/User ID does not exist|Login Not Allowed/i)).toBeInTheDocument();
  });
});
