import { useEffect, useRef, useState, useCallback, useMemo } from "react";
import axios from "axios";
import { useLocation, useNavigate } from "react-router-dom";
import useCustomSnackbar from "../utils/useCustomSnackbar";
import { useSelector, useDispatch } from "react-redux";
import { resolveConfig } from "../config/EnvironmentConfig";
import { setToken } from "../store/authSlice";
import { convertToKebabCase } from "../utils/CommonUtilities";

const useApi = () => {
    const [data, setData] = useState(null);
    const [error, setError] = useState(null);
    const [loading, setLoading] = useState(false);
    
    const navigate = useNavigate();
    const location = useLocation();
    const snackbar = useCustomSnackbar();
    const dispatch = useDispatch();
    
    const token = useSelector((state) => state.auth.token);
    const menus = useSelector((s) => s.menus.menus);
    const selectedMenuItem = useSelector((s) => s.menus.selectedMenuItem);
    const activeRequestsRef = useRef(new Set());

    /** 1. Silent Refresh Handler */
    const refreshToken = async () => {
        try {
            let oldToken = sessionStorage.getItem("accessToken") || token;
            if (!oldToken || oldToken === "undefined") return null;

            const res = await axios.get(
                `${resolveConfig("/LS") ?? ""}/Auth/refresh-token`,
                { params: { token: oldToken }, withCredentials: true }
            );
            
            if (res.status === 200 && res.data.token) {
                const newToken = res.data.token; 
                sessionStorage.setItem("accessToken", newToken);
                dispatch(setToken(newToken)); 
                return newToken;
            }
            return null;
        } catch (err) {
            console.error("Silent Refresh failed", err);
            return null;
        }
    };

    /** 2. callApi (Original Logic with Silent Refresh) */
    const callApi = useCallback(
        async (
            url,
            payload = null,
            method = "GET", // Default GET as per your file
            responseType = "json",
            contentType = "application/json",
            extraConfig = {},
            returnDataOnly = true
        ) => {
            // --- Your Original Service Resolution Logic ---
            const parts = url.split("/");
            const service = parts[1];
            const resolved = resolveConfig(`/${service}`);
            parts[1] = resolved;
            const Final_Url = parts.slice(1).join("/");

            const controller = new AbortController();
            activeRequestsRef.current.add(controller);
            setLoading(true);
            setError(null);

            const activeToken = sessionStorage.getItem("accessToken") || token;

            const config = {
                method: method.toUpperCase(),
                url: Final_Url,
                headers: {
                    Authorization: `Bearer ${activeToken}`,
                    "Content-Type": contentType,
                    // "X-Request-Type": xRequestType, // If needed add xRequestType back
                },
                responseType,
                withCredentials: true,
                signal: controller.signal,
                ...extraConfig,
            };

            if (payload !== null) {
                method.toUpperCase() === "GET" ? (config.params = payload) : (config.data = payload);
            }

            try {
                const response = await axios(config);

                if (!controller.signal.aborted) {
                    // --- Your Original 440 Handling ---
                    if (response?.data?.status === 440) {
                        console.error("You have logged in another session");
                        navigate("/");
                        return;
                    }

                    // --- Silent Refresh for 401 in Data ---
                    if (response?.data?.status === 401) {
                        const newToken = await refreshToken();
                        if (newToken) {
                            return callApi(url, payload, method, responseType, contentType, extraConfig, returnDataOnly);
                        } else {
                            navigate("/");
                            return;
                        }
                    }

                    setData(response.data);
                    return returnDataOnly ? response.data : response;
                }
            } catch (err) {
                const status = err.response?.status;

                // --- Catch Block Silent Refresh ---
                if (status === 401) {
                    const newToken = await refreshToken();
                    if (newToken) {
                        const originalConfig = err.config;
                        originalConfig.headers.Authorization = `Bearer ${newToken}`;
                        return axios(originalConfig);
                    }
                }

                if (status === 440) navigate("/");

                // --- Your Original Error & Snackbar Handling ---
                if (!axios.isCancel(err) && !controller.signal.aborted) {
                    const apiMessage = err.response?.data?.message || err.response?.statusText || "Something went wrong";
                    snackbar.showError(apiMessage, "error"); 
                    setError(err);
                }
            } finally {
                activeRequestsRef.current.delete(controller);
                setLoading(false);
            }
        },
        [navigate, snackbar, token, dispatch]
    );

    return { data, error, loading, callApi, refreshToken };
};

export default useApi;
